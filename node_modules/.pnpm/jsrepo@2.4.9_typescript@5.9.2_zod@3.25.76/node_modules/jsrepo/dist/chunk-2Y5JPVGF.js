import*as o from'valibot';import b from'chalk';var Q=o.object({name:o.string(),category:o.string(),localDependencies:o.array(o.string()),dependencies:o.array(o.string()),devDependencies:o.array(o.string()),tests:o.boolean(),docs:o.optional(o.boolean(),false),list:o.optional(o.boolean(),true),directory:o.string(),subdirectory:o.boolean(),files:o.array(o.string()),_imports_:o.record(o.string(),o.string())}),A=o.object({name:o.string(),blocks:o.array(Q)}),J=o.object({authors:o.optional(o.array(o.string())),bugs:o.optional(o.string()),description:o.optional(o.string()),homepage:o.optional(o.string()),repository:o.optional(o.string()),tags:o.optional(o.array(o.string()))}),q=o.record(o.string(),o.union([o.string(),o.object({version:o.string(),message:o.string()})])),K=o.object({name:o.string(),path:o.string(),expectedPath:o.optional(o.string()),optional:o.optional(o.boolean(),false)}),V=o.object({...K.entries,dependencies:o.optional(o.array(o.string())),devDependencies:o.optional(o.array(o.string()))}),X=o.union([o.literal("public"),o.literal("private"),o.literal("marketplace")]),F=o.object({name:o.optional(o.string()),version:o.optional(o.string()),meta:o.optional(J),access:o.optional(X),defaultPaths:o.optional(o.record(o.string(),o.string())),peerDependencies:o.optional(q),configFiles:o.optional(o.array(V)),categories:o.array(A)});var _="jsrepo-manifest.json",ae="jsrepo.json";var Z="main",w={name:"azure",matches:e=>e.toLowerCase().startsWith("azure"),parse:(e,r)=>{let t=O(e,r);return {url:t.url,specifier:t.specifier}},baseUrl:e=>{let{owner:r,repoName:t}=O(e,{fullyQualified:false});return `https://dev.azure.com/${r}/_git/${t}`},state:async e=>{let{url:r,owner:t,project:i,repoName:a,ref:s,refs:n}=O(e,{fullyQualified:false});return {owner:t,repoName:a,ref:s,refs:n,project:i,url:r,provider:w}},resolveRaw:async(e,r)=>{if(e.provider.name!==w.name)throw new Error(`You passed the incorrect state object (${e.provider.name}) to the ${w.name} provider.`);let{owner:t,repoName:i,project:a,ref:s,refs:n}=e,p=n==="tags"?"tag":"branch";return new URL(`https://dev.azure.com/${t}/${a}/_apis/git/repositories/${i}/items?path=${r}&api-version=7.2-preview.1&versionDescriptor.version=${s}&versionDescriptor.versionType=${p}`)},authHeader:e=>["Authorization",`Bearer ${e}`],formatFetchError:(e,r)=>`There was an error fetching \`${b.bold(r)}\` from ${b.bold(e.url)}.

${b.bold("This may be for one of the following reasons:")}
1. Either \`${b.bold(r)}\` or the containing repository doesn't exist
2. Your repository path is incorrect (wrong branch, wrong tag)
3. You are using an expired access token or a token that doesn't have access to this repository
4. The cached state for this git provider is incorrect (try using ${b.bold("--no-cache")})
`};function O(e,{fullyQualified:r}){let t=e.replaceAll(/(azure\/)/g,""),[i,a,s,...n]=t.split("/"),p;r&&(p=n.slice(n.length-2).join("/"),n=n.slice(0,n.length-2));let c=Z,l="heads";return ["tags","heads"].includes(n[0])&&(l=n[0],n[1]&&n[1]!==""&&(c=n[1])),{url:`azure/${i}/${a}/${s}${c?`/${l}/${c}`:""}`,owner:i,repoName:s,project:a,ref:c,refs:l,specifier:p}}function h(e,r){for(let t of r)if(e.startsWith(t))return t}function ue(e,r){for(let t of r)if(e.endsWith(t))return t}var B="main",m={name:"bitbucket",matches:e=>h(e.toLowerCase(),["bitbucket","https://bitbucket.org"])!==void 0,parse:(e,r)=>{let t=j(e,r);return {url:t.url,specifier:t.specifier}},baseUrl:e=>{let{owner:r,repoName:t}=j(e,{fullyQualified:false});return `https://bitbucket.org/${r}/${t}`},state:async(e,{token:r,fetch:t=fetch}={})=>{let{url:i,owner:a,repoName:s,ref:n}=j(e,{fullyQualified:false});if(n===void 0)try{let p=new Headers;if(r!==void 0){let[l,g]=m.authHeader(r);p.append(l,g);}let c=await t(`https://api.bitbucket.org/2.0/repositories/${a}/${s}`,{headers:p});c.ok?n=(await c.json()).mainbranch.name:n=B;}catch{n=B;}return {owner:a,ref:n,repoName:s,url:i,provider:m}},resolveRaw:async(e,r)=>{if(e.provider.name!==m.name)throw new Error(`You passed the incorrect state object (${e.provider.name}) to the ${m.name} provider.`);let{owner:t,repoName:i,ref:a}=e;return new URL(r,`https://api.bitbucket.org/2.0/repositories/${t}/${i}/src/${a}/`)},authHeader:e=>["Authorization",`Bearer ${e}`],formatFetchError:(e,r)=>`There was an error fetching \`${b.bold(r)}\` from ${b.bold(e.url)}.

${b.bold("This may be for one of the following reasons:")}
1. Either \`${b.bold(r)}\` or the containing repository doesn't exist
2. Your repository path is incorrect (wrong branch, wrong tag)
3. You are using an expired access token or a token that doesn't have access to this repository
4. The cached state for this git provider is incorrect (try using ${b.bold("--no-cache")})
`};function j(e,{fullyQualified:r=false}){let t=e.replaceAll(/(https:\/\/bitbucket.org\/)|(bitbucket\/)/g,""),[i,a,...s]=t.split("/"),n;r&&(n=s.slice(s.length-2).join("/"),s=s.slice(0,s.length-2));let p;return s[0]==="src"&&(p=s[1]),{url:`bitbucket/${i}/${a}${p?`/src/${p}`:""}`,specifier:n,owner:i,repoName:a,ref:p}}var z="main",v={name:"github",matches:e=>h(e.toLowerCase(),["github","https://github.com"])!==void 0,parse:(e,r)=>{let t=k(e,r);return {url:t.url,specifier:t.specifier}},baseUrl:e=>{let{owner:r,repoName:t}=k(e,{fullyQualified:false});return `https://github.com/${r}/${t}`},state:async(e,{token:r}={})=>{let{url:t,owner:i,repoName:a,ref:s}=k(e,{fullyQualified:false});if(s===void 0)try{let n=await fetch(`https://api.github.com/repos/${i}/${a}`,{headers:{Authorization:`Bearer ${r}`}});n.ok?s=(await n.json()).default_branch:s=z;}catch{s=z;}return {owner:i,ref:s,repoName:a,url:t,provider:v}},resolveRaw:async(e,r)=>{if(e.provider.name!==v.name)throw new Error(`You passed the incorrect state object (${e.provider.name}) to the ${v.name} provider.`);let{owner:t,repoName:i,ref:a}=e;return new URL(`${r}?ref=${a}`,`https://api.github.com/repos/${t}/${i}/contents/`)},authHeader:e=>["Authorization",`Bearer ${e}`],formatFetchError:(e,r)=>`There was an error fetching \`${b.bold(r)}\` from ${b.bold(e.url)}.

${b.bold("This may be for one of the following reasons:")}
1. Either \`${b.bold(r)}\` or the containing repository doesn't exist
2. Your repository path is incorrect (wrong branch, wrong tag)
3. You are using an expired access token or a token that doesn't have access to this repository
4. The cached state for this git provider is incorrect (try using ${b.bold("--no-cache")})
`};function k(e,{fullyQualified:r=false}){let t=e.replaceAll(/(https:\/\/github.com\/)|(github\/)/g,""),[i,a,...s]=t.split("/"),n;r&&(n=s.slice(s.length-2).join("/"),s=s.slice(0,s.length-2));let p;return s.length>0&&s[0]==="tree"&&(p=s[1]),{url:`github/${i}/${a}${p?`/tree/${p}`:""}`,specifier:n,owner:i,repoName:a,ref:p}}function f(...e){return e.map(r=>ee(r)).filter(Boolean).join("/")}function ee(e){let r=re(e);return te(r)}function re(e){let r=e;return r.startsWith("/")&&(r=r.slice(1)),r}function te(e){let r=e;return r.endsWith("/")&&(r=r.slice(0,r.length-1)),r}function C(e){let r=e;return r.endsWith("/")||(r=`${r}/`),r}var I="main",M="https://gitlab.com",y={name:"gitlab",matches:e=>h(e.toLowerCase(),["gitlab/","gitlab:","https://gitlab.com"])!==void 0,parse:(e,r)=>{let t=U(e,r);return {url:t.url,specifier:t.specifier}},baseUrl:e=>{let{baseUrl:r,owner:t,repoName:i}=U(e,{fullyQualified:false});return f(r,t,i)},state:async(e,{token:r,fetch:t=fetch}={})=>{let{baseUrl:i,url:a,owner:s,repoName:n,ref:p}=U(e,{fullyQualified:false});if(p===void 0)try{let c=new Headers;if(r!==void 0){let[g,G]=y.authHeader(r);c.append(g,G);}let l=await t(f(i,`api/v4/projects/${encodeURIComponent(`${s}/${n}`)}`),{headers:c});l.ok?p=(await l.json()).default_branch:p=I;}catch{p=I;}return {owner:s,repoName:n,ref:p,baseUrl:i,url:a,provider:y}},resolveRaw:async(e,r)=>{if(e.provider.name!==y.name)throw new Error(`You passed the incorrect state object (${e.provider.name}) to the ${y.name} provider.`);let{baseUrl:t,owner:i,repoName:a,ref:s}=e;return new URL(f(t,`api/v4/projects/${encodeURIComponent(`${i}/${a}`)}`,`repository/files/${encodeURIComponent(r)}/raw?ref=${s}`))},authHeader:e=>["PRIVATE-TOKEN",e],formatFetchError:(e,r,t)=>`There was an error fetching \`${b.bold(r)}\` from ${b.bold(e.url)}: ${t}.

${b.bold("This may be for one of the following reasons:")}
1. Either \`${b.bold(r)}\` or the containing repository doesn't exist
2. Your repository path is incorrect (wrong branch, wrong tag)
3. You are using an expired access token or a token that doesn't have access to this repository
4. The cached state for this git provider is incorrect (try using ${b.bold("--no-cache")})
`};function U(e,{fullyQualified:r}){let t=M;e.startsWith("gitlab:")&&(t=new URL(e.slice(7)).origin);let i=e.replaceAll(/gitlab\/|https:\/\/gitlab\.com\/|gitlab:https?:\/\/[^/]+\//g,""),[a,s,...n]=i.split("/"),p;r&&(p=n.slice(n.length-2).join("/"),n=n.slice(0,n.length-2));let c;if(n[0]==="-"&&n[1]==="tree")if(n[2].includes("?")){let[g]=n[2].split("?");c=g;}else c=n[2];return {url:f(t!==M?`gitlab:${t}`:t,`${a}/${s}${c?`/-/tree/${c}`:""}`),baseUrl:t,owner:a,repoName:s,ref:c,specifier:p}}var P={name:"http",matches:e=>{try{return new URL(e),!0}catch{return  false}},parse:(e,r)=>{let t=N(e,r);return {url:t.url,specifier:t.specifier}},baseUrl:e=>{let{url:r}=N(e,{fullyQualified:false});return new URL(r).origin},state:async e=>{let{url:r}=N(e,{fullyQualified:false});return {url:r,provider:P}},resolveRaw:async(e,r)=>{if(e.provider.name!==P.name)throw new Error(`You passed the incorrect state object (${e.provider.name}) to the ${P.name} provider.`);return new URL(r,e.url)},authHeader:e=>["Authorization",`Bearer ${e}`],formatFetchError:(e,r,t)=>`There was an error fetching ${b.bold(new URL(r,e.url).toString())}
	
${b.bold(t)}`};function N(e,{fullyQualified:r}){let t=new URL(e),i=t.pathname.split("/"),a;return r&&(a=i.slice(i.length-2).join("/"),i=i.slice(0,i.length-2)),{url:C(f(t.origin,...i)),specifier:a}}var Se=/^(?![-0-9])(?!.*--)[a-z0-9]*(?:-[a-z0-9]+)*$/gi,W="https://www.jsrepo.com",S={name:"jsrepo",matches:e=>e.startsWith("@"),parse:(e,r)=>{let t=L(e,r);return {url:t.url,specifier:t.specifier}},baseUrl:e=>{let{scope:r,registryName:t,version:i}=L(e,{fullyQualified:false});return `${W}/${r}/${t}/v/${i}`},state:async e=>({...L(e,{fullyQualified:false}),provider:S}),resolveRaw:async(e,r)=>{if(e.provider.name!==S.name)throw new Error(`You passed the incorrect state object (${e.provider.name}) to the ${S.name} provider.`);let{scope:t,registryName:i,version:a}=e;return new URL(`${W}/api/scopes/${t}/${i}/v/${a}/files/${r}`)},authHeader:e=>["x-api-key",e],formatFetchError:(e,r,t)=>{let{scope:i,registryName:a,version:s}=e;return `There was an error fetching ${r} from ${i}/${a}@${s}
	
${b.bold(t)}`}};function L(e,{fullyQualified:r}){let[t,i,...a]=e.split("/"),[s,n]=i.split("@"),p;return r&&(p=a.slice(a.length-2).join("/")),{url:`${t}/${i}`,specifier:p,scope:t,registryName:s,version:n??"latest"}}var T=class{_result;constructor(r){this._result=r;}match(r,t){return this._result.ok?r(this._result.val):t(this._result.err)}map(r){return this.match(t=>d(r(t)),t=>u(t))}mapOr(r,t){return this.match(i=>t(i),i=>r)}mapOrElse(r,t){return this.match(i=>t(i),i=>r(i))}mapErr(r){return this.match(t=>d(t),t=>u(r(t)))}mapErrOr(r,t){return this.match(i=>r,i=>t(i))}mapErrOrElse(r,t){return this.match(i=>r(i),i=>t(i))}isOk(){return this.match(()=>true,()=>false)}isErr(){return this.match(()=>false,()=>true)}unwrap(){return this.match(r=>r,()=>{throw new Error("Attempted to call `.unwrap()` on a non `Ok` value.")})}unwrapErr(){return this.match(()=>{throw new Error("Attempted to call `.unwrapErr()` on a non `Err` value.")},r=>r)}unwrapOr(r){return this.match(t=>t,t=>r)}unwrapErrOr(r){return this.match(()=>r,t=>t)}unwrapOrElse(r){return this.match(t=>t,t=>r(t))}unwrapErrOrElse(r){return this.match(t=>r(t),t=>t)}expect(r){return this.match(t=>t,()=>{throw new Error(r)})}expectErr(r){return this.match(()=>{throw new Error(r)},t=>t)}};function d(e){return new T({ok:true,val:e})}function u(e){return new T({ok:false,err:e})}function Y(e){let r;try{r=JSON.parse(e);}catch(i){return u(`Error parsing manifest json ${i}`)}if(Array.isArray(r)){let i=o.safeParse(o.array(A),r);return i.success?d({private:false,categories:i.output}):u(`Error parsing categories (array-based config) ${i.issues.join(" ")}`)}let t=o.safeParse(F,r);return t.success?d(t.output):u(`Error parsing manifest ${t.issues.join(" ")}`)}function je(e,r,t){return {name:t.name,version:t.version,meta:t.meta,access:t.access,defaultPaths:t.defaultPaths,peerDependencies:t.peerDependencies,configFiles:r,categories:e}}var ie=[S,v,y,m,w,P];function Ie(e){return ie.find(t=>t.matches(e))}async function ne(e,r,{verbose:t,fetch:i=fetch,token:a}={}){let s=await e.provider.resolveRaw(e,r);t?.(`Trying to fetch from ${s}`);try{let n={};if(a!==void 0&&e.provider.authHeader){let[c,l]=e.provider.authHeader(a);n[c]=l;}e.provider.name===v.name&&(n.Accept="application/vnd.github.raw+json");let p=await i(s.toString(),{headers:n});return t?.(`Got a response from ${s} ${p.status} ${p.statusText}`),p.ok?d(await p.text()):u(e.provider.formatFetchError(e,r,`${p.status} ${p.statusText}`))}catch(n){return u(e.provider.formatFetchError(e,r,n))}}async function Me(e,{fetch:r=fetch,...t}={}){let i=await ne(e,_,{fetch:r,...t});return i.isErr()?u(i.unwrapErr()):Y(i.unwrap())}export{ne as A,Me as B,d as a,u as b,f as c,Q as d,A as e,J as f,q as g,K as h,V as i,X as j,F as k,ue as l,_ as m,ae as n,Y as o,je as p,w as q,m as r,v as s,y as t,P as u,Se as v,W as w,S as x,ie as y,Ie as z};//# sourceMappingURL=chunk-2Y5JPVGF.js.map
//# sourceMappingURL=chunk-2Y5JPVGF.js.map